28SW-0334-1101.0	BUG17572-20240913 The practitioner is not saved if update from clinical tab patient inside view

Fixed Solution

[AbpAuthorize(PatientManagementPermissions.PatientClinic.PatientClinical.Edit)]
public override async Task<PatientClinicalDTO> UpdateAsync(Guid id, CreateUpdatePatientClinicalDTO input)
{
    try
    {
        await _permissionChecker.PermissionCheck(PatientManagementPermissions.PatientClinic.PatientClinical.Edit);
        PatientClinicalDTO vClinicalDetails = new PatientClinicalDTO();
        var vData1 = await _clinicalRepository.AnyAsync(i => i.Id == id);
        if (vData1)
        {
           

                // If referringProviderFacilityId set to not  null
                if (input.referringProviderFacilityId != null)
                {
                    var existingPracticeManagement = await _practiceManagementRepository.FirstOrDefaultAsync(i => i.Id == input.referringProviderFacilityId);
                    if (existingPracticeManagement != null)
                    {
                        input.referringProviderFacility = existingPracticeManagement.practiceName;
                    }
                    else if (input.referringProviderFacilityId == Guid.Empty)
                    {
                        // If no referringProviderFacilityId is provided, set the referringProviderFacility to null 
                        input.referringProviderFacility = null;
                    }
                    else
                    {
                        throw new UserFriendlyException("Practice Not Found");
                    }
            }
            
        }
        else
        {
            throw new UserFriendlyException("No Patient Exist with the given ID");
        }


        #region PatientDataMonitor
        try
        {
            PatientDataMonitor patientDataDetails = (await _patientDataMonitorRepository.GetListAsync(a => a.patientId == input.patientId)).FirstOrDefault();
            if (patientDataDetails != null)
            {
                patientDataDetails.patientId = input.patientId;
                patientDataDetails.description = "CLINICAL";
                patientDataDetails.modifiedDate = DateTime.Now;
                patientDataDetails.TenantId = CurrentTenant.Id;
                var vPatient = await _patientDataMonitorRepository.UpdateAsync(patientDataDetails);
            }
        }
        catch (Exception ex)
        {
            throw new UserFriendlyException(ex.Message);
        }


        #endregion

        vClinicalDetails = await base.UpdateAsync(id, input);
        _scopedCacheService.RemoveScoped($"patientList_{CurrentTenant.Id}");
        return vClinicalDetails;


    }
    catch (Exception ex)
    {
        throw new UserFriendlyException(ex.Message);
    }
}
In ABP (Asp.Net Boilerplate), soft deletion is built into the framework. A "soft delete" means that an entity is not physically removed from the database but instead marked as deleted. This is often done by updating a `IsDeleted` field to `true`.

To implement soft delete in your ABP project, follow these steps:

### 1. **Inherit from `ISoftDelete` Interface**
The `ISoftDelete` interface is used to mark entities as soft-deletable. When this interface is implemented, the framework automatically handles setting the `IsDeleted` property to `true` when the `Delete` method is called.

Example:
```csharp
using Volo.Abp.Domain.Entities;
using Volo.Abp.Domain.Entities.Auditing;

public class MyEntity : FullAuditedEntity<Guid>, ISoftDelete
{
    public string Name { get; set; }

    // Other properties...
}
```

In this example:
- The `FullAuditedEntity` already includes soft delete functionality through the `ISoftDelete` interface.
- The `IsDeleted` property will be automatically managed.

### 2. **Soft Delete on Repository Level**
If you are using ABP's repositories, soft delete is automatically handled. However, if you want to manually apply soft delete logic, you can use the `DeleteAsync` method on the repository. It will not physically remove the record but will set the `IsDeleted` flag to `true`.

Example:
```csharp
public class MyAppService : ApplicationService
{
    private readonly IRepository<MyEntity, Guid> _myEntityRepository;

    public MyAppService(IRepository<MyEntity, Guid> myEntityRepository)
    {
        _myEntityRepository = myEntityRepository;
    }

    public async Task SoftDeleteEntityAsync(Guid id)
    {
        await _myEntityRepository.DeleteAsync(id);
    }
}
```

### 3. **Filter Out Deleted Entities**
By default, ABP automatically filters out entities marked as `IsDeleted = true`. If you need to include soft-deleted entities in queries, you can disable the filter using the `GetAllIncludingDeletedAsync` method.

Example:
```csharp
public async Task<List<MyEntity>> GetAllIncludingDeletedAsync()
{
    using (CurrentTenant.Change(null))
    {
        var query = await _myEntityRepository.WithDetailsAsync();
        return await AsyncExecuter.ToListAsync(query.IgnoreQueryFilters());  // Disables soft delete filter
    }
}
```

### 4. **Restoring Soft-Deleted Entities**
You can restore a soft-deleted entity by setting its `IsDeleted` flag back to `false`.

Example:
```csharp
public async Task RestoreEntityAsync(Guid id)
{
    var entity = await _myEntityRepository.GetAsync(id);
    entity.IsDeleted = false;

    await _myEntityRepository.UpdateAsync(entity);
}
```

With this setup, ABP handles the soft delete functionality for you, ensuring that entities marked as deleted are not returned in queries unless explicitly requested.
